(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{148:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return d}));var a=t(0),i=t.n(a);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=i.a.createContext({}),b=function(e){var n=i.a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},p=function(e){var n=b(e.components);return i.a.createElement(s.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return i.a.createElement(i.a.Fragment,{},n)}},u=i.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),p=b(t),u=a,d=p["".concat(l,".").concat(u)]||p[u]||m[u]||r;return t?i.a.createElement(d,c(c({ref:n},s),{},{components:t})):i.a.createElement(d,c({ref:n},s))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,l=new Array(r);l[0]=u;var c={};for(var o in n)hasOwnProperty.call(n,o)&&(c[o]=n[o]);c.originalType=e,c.mdxType="string"==typeof e?e:a,l[1]=c;for(var s=2;s<r;s++)l[s]=t[s];return i.a.createElement.apply(null,l)}return i.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},99:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return l})),t.d(n,"metadata",(function(){return c})),t.d(n,"toc",(function(){return o})),t.d(n,"default",(function(){return b}));var a=t(3),i=t(7),r=(t(0),t(148)),l={id:"utils",title:"Utils.jl",sidebar_label:"Utils.jl"},c={unversionedId:"api/utils",id:"api/utils",isDocsHomePage:!1,title:"Utils.jl",description:"alleles",source:"@site/docs/api/Utils.md",slug:"/api/utils",permalink:"/PopGen.jl/docs/api/utils",editUrl:"https://github.com/pdimens/popgen.jl/edit/documentation/docs/api/Utils.md",version:"current",lastUpdatedAt:1615157034,sidebar_label:"Utils.jl",sidebar:"docs",previous:{title:"Types.jl",permalink:"/PopGen.jl/docs/api/types"},next:{title:"VariantCall.jl",permalink:"/PopGen.jl/docs/api/variantcall"}},o=[{value:"<code>alleles</code>",id:"alleles",children:[]},{value:"<code>unique_alleles</code>",id:"unique_alleles",children:[]},{value:"<code>count_nonzeros</code>",id:"count_nonzeros",children:[]},{value:"<code>convert_coord</code>",id:"convert_coord",children:[]},{value:"<code>copy</code>",id:"copy",children:[]},{value:"<code>drop_monomorphic</code>",id:"drop_monomorphic",children:[]},{value:"<code>drop_monomorphic!</code>",id:"drop_monomorphic-1",children:[]},{value:"<code>generate_meta</code>",id:"generate_meta",children:[]},{value:"<code>loci_matrix</code>",id:"loci_matrix",children:[]},{value:"<code>nonmissing</code>",id:"nonmissing",children:[]},{value:"<code>nonmissings</code>",id:"nonmissings",children:[]},{value:"<code>multitest_missing</code>",id:"multitest_missing",children:[]},{value:"<code>pairwise_pairs</code>",id:"pairwise_pairs",children:[]},{value:"<code>partitionarray</code>",id:"partitionarray",children:[]},{value:"<code>phase</code>",id:"phase",children:[]},{value:"<code>reciprocal</code>",id:"reciprocal",children:[]},{value:"<code>safemean</code>",id:"safemean",children:[]},{value:"<code>size</code>",id:"size",children:[]},{value:"<code>sim_pairs</code>",id:"sim_pairs",children:[]},{value:"<code>sort</code>",id:"sort",children:[]},{value:"<code>strict_shuffle</code>",id:"strict_shuffle",children:[]},{value:"<code>strict_shuffle!</code>",id:"strict_shuffle-1",children:[]}],s={toc:o};function b(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},s,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h3",{id:"alleles"},Object(r.b)("inlineCode",{parentName:"h3"},"alleles")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-julia"}),"alleles(locus::T; miss::Bool = false) where T<:GenoArray\n")),Object(r.b)("p",null,"Return an array of all the non-missing alleles of a locus. Use\n",Object(r.b)("inlineCode",{parentName:"p"},"miss = true")," to include missing values."),Object(r.b)("hr",null),Object(r.b)("h3",{id:"unique_alleles"},Object(r.b)("inlineCode",{parentName:"h3"},"unique_alleles")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-julia"}),"unique_alleles(locus::T) where T<:GenotypeArray\n")),Object(r.b)("p",null,"Return an array of all the unique non-missing alleles of a locus."),Object(r.b)("hr",null),Object(r.b)("h3",{id:"count_nonzeros"},Object(r.b)("inlineCode",{parentName:"h3"},"count_nonzeros")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-julia"}),"count_nonzeros(x::AbstractVector{T}) where T<:Real\n")),Object(r.b)("p",null,"Return the number of non-zero values in a vector"),Object(r.b)("hr",null),Object(r.b)("h3",{id:"convert_coord"},Object(r.b)("inlineCode",{parentName:"h3"},"convert_coord")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-julia"}),"convert_coord(coordinate::string)\n")),Object(r.b)("p",null,"Takes non-decimal-degree format as a ",Object(r.b)("inlineCode",{parentName:"p"},"String")," and returns it as a decimal degree\n",Object(r.b)("inlineCode",{parentName:"p"},"Float32"),". Can be broadcasted over an array of coordinate strings to convert them."),Object(r.b)("h4",{id:"formatting-requirements"},"Formatting requirements"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Coordinates as a ",Object(r.b)("inlineCode",{parentName:"li"},"String")," separated by spaces (",Object(r.b)("inlineCode",{parentName:"li"},'"11 43 41"'),") or colons (",Object(r.b)("inlineCode",{parentName:"li"},'"11:43:41"'),")"),Object(r.b)("li",{parentName:"ul"},"Must use negative sign (",Object(r.b)("inlineCode",{parentName:"li"},'"-11 43.52"'),") or single-letter cardinal direction (",Object(r.b)("inlineCode",{parentName:"li"},'"11 43.52W"'),")"),Object(r.b)("li",{parentName:"ul"},"Missing data should be coded as the string ",Object(r.b)("inlineCode",{parentName:"li"},'"missing"')," (can be accomplished with ",Object(r.b)("inlineCode",{parentName:"li"},"replace!()"),")"),Object(r.b)("li",{parentName:"ul"},"Can mix colons and spaces (although it's bad practice)\n",Object(r.b)("strong",{parentName:"li"},"Example"))),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'julia> convert_coord("-41 31.52")\n-41.5253f0\njulia> convert_coord.(["-41 31.52", "25 11:54S"])\n2-element Array{Float32,1}:\n-41.5253\n-25.1983\n')),Object(r.b)("hr",null),Object(r.b)("h3",{id:"copy"},Object(r.b)("inlineCode",{parentName:"h3"},"copy")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-julia"}),"copy(data::PopData)\n")),Object(r.b)("p",null,"Creates a copy of ",Object(r.b)("inlineCode",{parentName:"p"},"PopData"),"."),Object(r.b)("hr",null),Object(r.b)("h3",{id:"drop_monomorphic"},Object(r.b)("inlineCode",{parentName:"h3"},"drop_monomorphic")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"drop_monomorphic(data::PopData)\n")),Object(r.b)("p",null,"Return a ",Object(r.b)("inlineCode",{parentName:"p"},"PopData")," object omitting any monomorphic loci. Will inform you which loci were removed."),Object(r.b)("hr",null),Object(r.b)("h3",{id:"drop_monomorphic-1"},Object(r.b)("inlineCode",{parentName:"h3"},"drop_monomorphic!")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"drop_monomorphic!(data::PopData)\n")),Object(r.b)("p",null,"Edit a ",Object(r.b)("inlineCode",{parentName:"p"},"PopData")," object in place by omitting any monomorphic loci. Will inform you which loci were removed."),Object(r.b)("hr",null),Object(r.b)("h3",{id:"generate_meta"},Object(r.b)("inlineCode",{parentName:"h3"},"generate_meta")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-julia"}),"generate_meta(data::DataFrame)\n")),Object(r.b)("p",null,"Given a genotype DataFrame formatted like ",Object(r.b)("inlineCode",{parentName:"p"},"PopData.loci"),", generates a corresponding\n",Object(r.b)("inlineCode",{parentName:"p"},"meta")," DataFrame. In other words, it creates the ",Object(r.b)("inlineCode",{parentName:"p"},".meta")," part of ",Object(r.b)("inlineCode",{parentName:"p"},"PopData")," from the ",Object(r.b)("inlineCode",{parentName:"p"},".loci")," part."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"julia> cats = @nancycats ;\njulia> cats_nometa = cats.loci ;\njulia> cats_meta = generate_meta(cats_nometa)\n237\xd75 DataFrame\n Row \u2502 name    population  ploidy  longitude  latitude \n     \u2502 String  String      Int8    Float32?   Float32? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 N215    1                2   missing   missing  \n   2 \u2502 N216    1                2   missing   missing  \n   3 \u2502 N217    1                2   missing   missing  \n   4 \u2502 N218    1                2   missing   missing  \n   5 \u2502 N219    1                2   missing   missing  \n   6 \u2502 N220    1                2   missing   missing  \n   7 \u2502 N221    1                2   missing   missing  \n  \u22ee  \u2502   \u22ee         \u22ee         \u22ee         \u22ee         \u22ee\n 232 \u2502 N295    17               2   missing   missing  \n 233 \u2502 N296    17               2   missing   missing  \n 234 \u2502 N297    17               2   missing   missing  \n 235 \u2502 N281    17               2   missing   missing  \n 236 \u2502 N289    17               2   missing   missing  \n 237 \u2502 N290    17               2   missing   missing  \n        \n\n----\n\n### `loci_dataframe`\n```julia\nloci_dataframe(data::PopData)\n")),Object(r.b)("p",null,"Return a wide ",Object(r.b)("inlineCode",{parentName:"p"},"DataFrame")," of samples as columns, ommitting population information."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"julia> loci_dataframe(@nancycats)\n9\xd7237 DataFrame. Omitted printing of 232 columns\n\u2502 Row \u2502 N215       \u2502 N216       \u2502 N217       \u2502 N218       \u2502 N219       \u2502\n\u2502     \u2502 Tuple\u2026?    \u2502 Tuple\u2026?    \u2502 Tuple\u2026?    \u2502 Tuple\u2026?    \u2502 Tuple\u2026?    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 missing    \u2502 missing    \u2502 (135, 143) \u2502 (133, 135) \u2502 (133, 135) \u2502\n\u2502 2   \u2502 (136, 146) \u2502 (146, 146) \u2502 (136, 146) \u2502 (138, 138) \u2502 (140, 146) \u2502\n\u2502 3   \u2502 (139, 139) \u2502 (139, 145) \u2502 (141, 141) \u2502 (139, 141) \u2502 (141, 145) \u2502\n\u2502 4   \u2502 (116, 120) \u2502 (120, 126) \u2502 (116, 116) \u2502 (116, 126) \u2502 (126, 126) \u2502\n\u2502 5   \u2502 (156, 156) \u2502 (156, 156) \u2502 (152, 156) \u2502 (150, 150) \u2502 (152, 152) \u2502\n\u2502 6   \u2502 (142, 148) \u2502 (142, 148) \u2502 (142, 142) \u2502 (142, 148) \u2502 (142, 148) \u2502\n\u2502 7   \u2502 (199, 199) \u2502 (185, 199) \u2502 (197, 197) \u2502 (199, 199) \u2502 (193, 199) \u2502\n\u2502 8   \u2502 (113, 113) \u2502 (113, 113) \u2502 (113, 113) \u2502 (91, 105)  \u2502 (113, 113) \u2502\n\u2502 9   \u2502 (208, 208) \u2502 (208, 208) \u2502 (210, 210) \u2502 (208, 208) \u2502 (208, 208) \u2502\n")),Object(r.b)("hr",null),Object(r.b)("h3",{id:"loci_matrix"},Object(r.b)("inlineCode",{parentName:"h3"},"loci_matrix")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-julia"}),"loci_matrix(data::PopData)\n")),Object(r.b)("p",null,"Return a matrix of genotypes with dimensions ",Object(r.b)("inlineCode",{parentName:"p"},"samples \xd7 loci"),".\nRows are samples and columns are loci. Will return an error if ploidy varies between samples. "),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"julia> loci_matrix(@nancycats)\n237\xd79 Array{Union{Missing, Tuple{Int16,Int16}},2}:\n missing     (136, 146)  (139, 139)  \u2026  (199, 199)  (113, 113)  (208, 208)\n missing     (146, 146)  (139, 145)     (185, 199)  (113, 113)  (208, 208)\n (135, 143)  (136, 146)  (141, 141)     (197, 197)  (113, 113)  (210, 210)\n (133, 135)  (138, 138)  (139, 141)     (199, 199)  (91, 105)   (208, 208)\n (133, 135)  (140, 146)  (141, 145)     (193, 199)  (113, 113)  (208, 208)\n (135, 143)  (136, 146)  (145, 149)  \u2026  (193, 195)  (91, 113)   (208, 208)\n (135, 135)  (136, 146)  (139, 145)     (199, 199)  (105, 113)  (208, 208)\n (135, 143)  (136, 146)  (135, 149)     (193, 197)  (91, 91)    (208, 212)\n (137, 143)  (136, 146)  (139, 139)     (197, 197)  (105, 113)  (208, 212)\n (135, 135)  (132, 132)  (141, 145)     (197, 197)  (91, 105)   (208, 208)\n (137, 141)  (130, 136)  (137, 145)  \u2026  (193, 199)  (91, 91)    (182, 182)\n (129, 133)  (130, 136)  (135, 145)     (193, 199)  (91, 113)   (182, 208)\n \u22ee                                   \u22f1                          \n (133, 135)  (136, 136)  (135, 139)  \u2026  (199, 199)  (113, 113)  (182, 182)\n (133, 141)  (136, 136)  (135, 139)     (197, 197)  (113, 113)  (182, 208)\n (133, 141)  (130, 146)  (141, 141)     (191, 199)  missing     (208, 208)\n (123, 133)  (138, 138)  (141, 145)     (191, 197)  missing     (208, 208)\n (123, 133)  (138, 138)  (139, 139)     (197, 199)  missing     (208, 208)\n (133, 141)  (136, 146)  (139, 139)  \u2026  (197, 197)  missing     (208, 208)\n (133, 141)  (130, 136)  (139, 145)     (191, 199)  missing     (208, 208)\n (133, 141)  (136, 146)  (139, 145)     (199, 199)  missing     (208, 220)\n (133, 143)  (130, 130)  (135, 145)     (197, 197)  missing     (208, 208)\n (135, 141)  (136, 144)  (143, 143)     (191, 197)  (113, 117)  (208, 208)\n (137, 143)  (130, 136)  (135, 145)  \u2026  (193, 199)  (113, 117)  (208, 208)\n (135, 141)  (130, 146)  (135, 139)     (197, 197)  missing     (208, 208)\n")),Object(r.b)("hr",null),Object(r.b)("h3",{id:"nonmissing"},Object(r.b)("inlineCode",{parentName:"h3"},"nonmissing")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-julia"}),"nonmissing(vec::T) where T<:AbstractArray\n")),Object(r.b)("p",null,"Convenience function to count the number of non-",Object(r.b)("inlineCode",{parentName:"p"},"missing")," values in a vector."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"nonmissing(data::PopData, locus::String)\n")),Object(r.b)("p",null,"Convenience function to count the number of non-",Object(r.b)("inlineCode",{parentName:"p"},"missing")," samples\nat a locus."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-julia"}),"nonmissing(data::PopData, locus::String)\n")),Object(r.b)("p",null,"Convenience function to count the number of non-",Object(r.b)("inlineCode",{parentName:"p"},"missing")," samples"),Object(r.b)("hr",null),Object(r.b)("h3",{id:"nonmissings"},Object(r.b)("inlineCode",{parentName:"h3"},"nonmissings")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-julia"}),"nonmissings(vec1::AbstractVector, vec2::AbstractVector)\n")),Object(r.b)("p",null,"Return a vector of indices where neither input vectors have a ",Object(r.b)("inlineCode",{parentName:"p"},"missing")," value, i.e. an\nintersection of the indices of their non-missing elements."),Object(r.b)("hr",null),Object(r.b)("h3",{id:"multitest_missing"},Object(r.b)("inlineCode",{parentName:"h3"},"multitest_missing")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-julia"}),"multitest_missing(pvals::Array{Float64,1}, correction::String)\n")),Object(r.b)("p",null,"Modification to ",Object(r.b)("inlineCode",{parentName:"p"},"MultipleTesting.adjust")," to include ",Object(r.b)("inlineCode",{parentName:"p"},"missing")," values in the\nreturned array. Missing values are first removed from the array, the appropriate\ncorrection made, then missing values are re-added to the array at their original\npositions. See MultipleTesting.jl docs for full more detailed information."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-julia"}),'multitest_missing([0.1, 0.01, 0.005, 0.3], "bh")`\n')),Object(r.b)("h4",{id:"correction-methods-case-insensitive"},Object(r.b)("inlineCode",{parentName:"h4"},"correction")," methods (case insensitive)"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},'"bonferroni"')," : Bonferroni adjustment"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},'"holm"')," : Holm adjustment"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},'"hochberg"')," : Hochberg adjustment"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},'"bh"')," : Benjamini-Hochberg adjustment"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},'"by"')," : Benjamini-Yekutieli adjustment"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},'"bl"')," : Benjamini-Liu adjustment"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},'"hommel"')," : Hommel adjustment"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},'"sidak"')," : \u0160id\xe1k adjustment"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},'"forwardstop"')," or ",Object(r.b)("inlineCode",{parentName:"li"},'"fs"')," : Forward-Stop adjustment"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},'"bc"')," : Barber-Cande\u0300s adjustment")),Object(r.b)("hr",null),Object(r.b)("h3",{id:"pairwise_pairs"},Object(r.b)("inlineCode",{parentName:"h3"},"pairwise_pairs")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-julia"}),"pairwise_pairs(smp_names::Vector{T}) hwere T\n")),Object(r.b)("p",null,"Given a vector of some iterable, returns a vector of tuples of unique all x\nall combinations of pairs, excluding self-comparisons."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'julia> samps = ["red_1", "red_2", "blue_1", "blue_2"] ;\njulia> pairwise_pairs(samps)\n6-element Array{Tuple{String,String},1}:\n ("red_1", "red_2")\n ("red_1", "blue_1")\n ("red_1", "blue_2")\n ("red_2", "blue_1")\n ("red_2", "blue_2")\n ("blue_1", "blue_2")\n')),Object(r.b)("hr",null),Object(r.b)("h3",{id:"partitionarray"},Object(r.b)("inlineCode",{parentName:"h3"},"partitionarray")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-julia"}),"partitionarray(array::AbstractArray, steps::AbstractVector{<:Integer})\n")),Object(r.b)("p",null,"Like ",Object(r.b)("inlineCode",{parentName:"p"},"Base.Iterators.partition"),", except you can apply arbitrary sizes to\npartition the array by. The ",Object(r.b)("inlineCode",{parentName:"p"},"steps")," must add up to the total row length\nof the array."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"julia> partitionmatrix(rand(20,5), [10,3,4,3]) .|> size\n((10, 5), (3, 5), (4, 5), (3, 5))\n")),Object(r.b)("hr",null),Object(r.b)("h3",{id:"phase"},Object(r.b)("inlineCode",{parentName:"h3"},"phase")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"phase(data::PopData)\n")),Object(r.b)("p",null,"Return a ",Object(r.b)("inlineCode",{parentName:"p"},"Vector")," of length ",Object(r.b)("inlineCode",{parentName:"p"},"ploidy")," composed of allele matrices with dimensions ",Object(r.b)("inlineCode",{parentName:"p"},"samples \xd7 loci"),".\nRows are samples and columns are loci. Will return an error if ploidy varies between samples. "),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"julia> mtx = phase(@nancycats)\n2-element Array{Array{Union{Missing, Int16},2},1}:\n [missing 136 \u2026 113 208; missing 146 \u2026 113 208; \u2026 ; 137 130 \u2026 113 208; 135 130 \u2026 missing 208]\n [missing 146 \u2026 113 208; missing 146 \u2026 113 208; \u2026 ; 143 136 \u2026 117 208; 141 146 \u2026 missing 208]\njulia> mtx[1]\n237\xd79 Array{Union{Missing, Int16},2}:\n    missing  136  139  116         156  142  199  113         208\n    missing  146  139  120         156  142  185  113         208\n 135         136  141  116         152  142  197  113         210\n 133         138  139  116         150  142  199   91         208\n 133         140  141  126         152  142  193  113         208\n 135         136  145  120         150  148  193   91         208\n 135         136  139  116         152  142  199  105         208\n 135         136  135  120         154  142  193   91         208\n 137         136  139  116         150  142  197  105         208\n 135         132  141  120         150  148  197   91         208\n 137         130  137  128         152  142  193   91         182\n 129         130  135  126         144  140  193   91         182\n   \u22ee                                      \u22ee                   \n 133         136  135     missing  146  142  199  113         182\n 133         136  135     missing  150  142  197  113         182\n 133         130  141     missing  148  142  191     missing  208\n 123         138  141     missing  148  142  191     missing  208\n 123         138  139     missing  150  142  197     missing  208\n 133         136  139     missing  150  142  197     missing  208\n 133         130  139     missing  152  142  191     missing  208\n 133         136  139     missing  150  142  199     missing  208\n 133         130  135     missing  148  142  197     missing  208\n 135         136  143     missing  144  142  191  113         208\n 137         130  135     missing  150  142  193  113         208\n 135         130  135     missing  150  142  197     missing  208\n")),Object(r.b)("hr",null),Object(r.b)("h3",{id:"reciprocal"},Object(r.b)("inlineCode",{parentName:"h3"},"reciprocal")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-julia"}),"reciprocal(num::T) where T <: Signed\n")),Object(r.b)("p",null,"Returns the reciprocal (1/number) of a number. Will return ",Object(r.b)("inlineCode",{parentName:"p"},"0")," when\nthe number is ",Object(r.b)("inlineCode",{parentName:"p"},"0")," instead of returning ",Object(r.b)("inlineCode",{parentName:"p"},"Inf"),"."),Object(r.b)("hr",null),Object(r.b)("h3",{id:"safemean"},Object(r.b)("inlineCode",{parentName:"h3"},"safemean")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-julia"}),"safemean(::AbstractVector{T}) where T<:Real\n")),Object(r.b)("p",null,"A wrapper for ",Object(r.b)("inlineCode",{parentName:"p"},"StatsBase.mean")," to calculate a mean after skipping ",Object(r.b)("inlineCode",{parentName:"p"},"Inf"),", ",Object(r.b)("inlineCode",{parentName:"p"},"-Inf"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"NaN")," values."),Object(r.b)("hr",null),Object(r.b)("h3",{id:"size"},Object(r.b)("inlineCode",{parentName:"h3"},"size")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-julia"}),"Base.size(data::PopData)\n")),Object(r.b)("p",null,"Returns a ",Object(r.b)("inlineCode",{parentName:"p"},"NamedTuple")," of the number of samples and loci in a ",Object(r.b)("inlineCode",{parentName:"p"},"PopData")," object."),Object(r.b)("hr",null),Object(r.b)("h3",{id:"sim_pairs"},Object(r.b)("inlineCode",{parentName:"h3"},"sim_pairs")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-julia"}),"sim_pairs(data::Vector{String})\n")),Object(r.b)("p",null,"Takes a Vector of sample names and returns a Tuple of sample pairs, grouped by simulation\nnumber. This is an internal function used for isolating sibship pairs from simulated shipship\npairs (via ",Object(r.b)("inlineCode",{parentName:"p"},"PopGenSims.jl"),") to perform ",Object(r.b)("inlineCode",{parentName:"p"},"relatedness")," estimates only on those pairs."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'julia> a = ["sim1_off1", "sim1_off2", "sim2_off1", "sim2_off2"] ;\njulia> sim_pairs(a)\n("sim1_off1", "sim1_off2")\n("sim2_off1", "sim2_off2")\n')),Object(r.b)("hr",null),Object(r.b)("h3",{id:"sort"},Object(r.b)("inlineCode",{parentName:"h3"},"sort")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-julia"}),"Base.sort(x::NTuple{N,T}) where N where T <: Signed \n")),Object(r.b)("p",null,"Sort the integers within a Tuple and return the sorted Tuple."),Object(r.b)("hr",null),Object(r.b)("h3",{id:"strict_shuffle"},Object(r.b)("inlineCode",{parentName:"h3"},"strict_shuffle")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-julia"}),"strict_shuffle(x::T) where T <: AbstractArray\n")),Object(r.b)("p",null,"Shuffle only the non-missing values of a Vector and return a copy of the vector,\nkeeping the ",Object(r.b)("inlineCode",{parentName:"p"},"missing")," values at their original locations.\nUse ",Object(r.b)("inlineCode",{parentName:"p"},"strict_shuffle!")," to edit in-place instead of returning a copy."),Object(r.b)("hr",null),Object(r.b)("h3",{id:"strict_shuffle-1"},Object(r.b)("inlineCode",{parentName:"h3"},"strict_shuffle!")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-julia"}),"strict_shuffle!(x::T)! where T <: AbstractArray\n")),Object(r.b)("p",null,"Shuffle only the non-missing values of a Vector, keeping the\n",Object(r.b)("inlineCode",{parentName:"p"},"missing")," values at their original locations. Use ",Object(r.b)("inlineCode",{parentName:"p"},"strict_shuffle"),"\nto return a copy instead of editing in-place."))}b.isMDXComponent=!0}}]);